<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Time Tabling: CClause Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Time Tabling
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCClause-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CClause Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for representing a clause.  
 <a href="classCClause.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cclause_8h_source.html">cclause.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae32c467fe55dc2302a4ea0d55daea9b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#ae32c467fe55dc2302a4ea0d55daea9b3">CClause</a> (const std::vector&lt; Lit &gt; &amp;)</td></tr>
<tr class="memdesc:ae32c467fe55dc2302a4ea0d55daea9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object.  <a href="#ae32c467fe55dc2302a4ea0d55daea9b3">More...</a><br /></td></tr>
<tr class="separator:ae32c467fe55dc2302a4ea0d55daea9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80bc7f6d1c6a83d4992e4e7b8ad002a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#ab80bc7f6d1c6a83d4992e4e7b8ad002a">CClause</a> (const Lit &amp;)</td></tr>
<tr class="memdesc:ab80bc7f6d1c6a83d4992e4e7b8ad002a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object.  <a href="#ab80bc7f6d1c6a83d4992e4e7b8ad002a">More...</a><br /></td></tr>
<tr class="separator:ab80bc7f6d1c6a83d4992e4e7b8ad002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801271e923e1c636c05b15d7ddbf58f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a801271e923e1c636c05b15d7ddbf58f5">CClause</a> (const Var &amp;)</td></tr>
<tr class="memdesc:a801271e923e1c636c05b15d7ddbf58f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object.  <a href="#a801271e923e1c636c05b15d7ddbf58f5">More...</a><br /></td></tr>
<tr class="separator:a801271e923e1c636c05b15d7ddbf58f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9b02ced9c74b06483727ded8de783"><td class="memItemLeft" align="right" valign="top"><a id="a94e9b02ced9c74b06483727ded8de783"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a94e9b02ced9c74b06483727ded8de783">CClause</a> ()</td></tr>
<tr class="memdesc:a94e9b02ced9c74b06483727ded8de783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object, as an empty clause. <br /></td></tr>
<tr class="separator:a94e9b02ced9c74b06483727ded8de783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ea1c0cecdb9cae3e705e54120ca1ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classCClause.html">CClause</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a25ea1c0cecdb9cae3e705e54120ca1ea">operator~</a> ()</td></tr>
<tr class="memdesc:a25ea1c0cecdb9cae3e705e54120ca1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the operator to negate the clause in this object.  <a href="#a25ea1c0cecdb9cae3e705e54120ca1ea">More...</a><br /></td></tr>
<tr class="separator:a25ea1c0cecdb9cae3e705e54120ca1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42c44c0a5402bfb3073ac5de1912056"><td class="memItemLeft" align="right" valign="top"><a id="af42c44c0a5402bfb3073ac5de1912056"></a>
std::vector&lt; <a class="el" href="classCClause.html">CClause</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;</b> (const <a class="el" href="classCClause.html">CClause</a> &amp;)</td></tr>
<tr class="separator:af42c44c0a5402bfb3073ac5de1912056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0222ca8feccdb348d25cd80f125eb626"><td class="memItemLeft" align="right" valign="top"><a id="a0222ca8feccdb348d25cd80f125eb626"></a>
<a class="el" href="classClauses.html">Clauses</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator &amp;</b> (const <a class="el" href="classClauses.html">Clauses</a> &amp;)</td></tr>
<tr class="separator:a0222ca8feccdb348d25cd80f125eb626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff25ccbdbc70021e59095715bd2334c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCClause.html">CClause</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#acff25ccbdbc70021e59095715bd2334c">operator|</a> (const <a class="el" href="classCClause.html">CClause</a> &amp;)</td></tr>
<tr class="memdesc:acff25ccbdbc70021e59095715bd2334c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the operator to perform a disjunction of two clauses.  <a href="#acff25ccbdbc70021e59095715bd2334c">More...</a><br /></td></tr>
<tr class="separator:acff25ccbdbc70021e59095715bd2334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfb51b369ecc9cf8a73b1b89bb9d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClauses.html">Clauses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#acbfb51b369ecc9cf8a73b1b89bb9d8c6">operator|</a> (const <a class="el" href="classClauses.html">Clauses</a> &amp;)</td></tr>
<tr class="memdesc:acbfb51b369ecc9cf8a73b1b89bb9d8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the operator to perform a disjunction between a clause and a set of <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a>.  <a href="#acbfb51b369ecc9cf8a73b1b89bb9d8c6">More...</a><br /></td></tr>
<tr class="separator:acbfb51b369ecc9cf8a73b1b89bb9d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537843f7b72a69746dc3f9d63cc2d981"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classCClause.html">CClause</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a537843f7b72a69746dc3f9d63cc2d981">operator&gt;&gt;</a> (const <a class="el" href="classCClause.html">CClause</a> &amp;)</td></tr>
<tr class="memdesc:a537843f7b72a69746dc3f9d63cc2d981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the operator to perform an implication with another clause.  <a href="#a537843f7b72a69746dc3f9d63cc2d981">More...</a><br /></td></tr>
<tr class="separator:a537843f7b72a69746dc3f9d63cc2d981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa225e0e4dc1c5025f5a2544a328e27df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClauses.html">Clauses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#aa225e0e4dc1c5025f5a2544a328e27df">operator&gt;&gt;</a> (const <a class="el" href="classClauses.html">Clauses</a> &amp;)</td></tr>
<tr class="memdesc:aa225e0e4dc1c5025f5a2544a328e27df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the operator to perform an implication with a set of <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a>.  <a href="#aa225e0e4dc1c5025f5a2544a328e27df">More...</a><br /></td></tr>
<tr class="separator:aa225e0e4dc1c5025f5a2544a328e27df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053b23b6f497d0f95ebd97a5a962fc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a6053b23b6f497d0f95ebd97a5a962fc5">createLitAndAdd</a> (const Var &amp;)</td></tr>
<tr class="memdesc:a6053b23b6f497d0f95ebd97a5a962fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Lit, a literal, given a variable, a Var, and adds it to the clause.  <a href="#a6053b23b6f497d0f95ebd97a5a962fc5">More...</a><br /></td></tr>
<tr class="separator:a6053b23b6f497d0f95ebd97a5a962fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00619c09bda108b810c6df25d3308ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#ab00619c09bda108b810c6df25d3308ff">createLitAndAdd</a> (const Var &amp;, const Var &amp;)</td></tr>
<tr class="memdesc:ab00619c09bda108b810c6df25d3308ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates Lits given two Vars and adds them to the clause.  <a href="#ab00619c09bda108b810c6df25d3308ff">More...</a><br /></td></tr>
<tr class="separator:ab00619c09bda108b810c6df25d3308ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde8b265a6235e778ba62e5b1287a541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#afde8b265a6235e778ba62e5b1287a541">createLitAndAdd</a> (const Var &amp;, const Var &amp;, const Var &amp;)</td></tr>
<tr class="memdesc:afde8b265a6235e778ba62e5b1287a541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates Lits given three Vars and adds them to the clause.  <a href="#afde8b265a6235e778ba62e5b1287a541">More...</a><br /></td></tr>
<tr class="separator:afde8b265a6235e778ba62e5b1287a541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59375f274b0a5667a5fc6869b29e02e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a59375f274b0a5667a5fc6869b29e02e3">addLits</a> (const Lit &amp;)</td></tr>
<tr class="memdesc:a59375f274b0a5667a5fc6869b29e02e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Lit, a literal, to the clause.  <a href="#a59375f274b0a5667a5fc6869b29e02e3">More...</a><br /></td></tr>
<tr class="separator:a59375f274b0a5667a5fc6869b29e02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3f270ceed5598a0d7615c9ef355077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#abe3f270ceed5598a0d7615c9ef355077">addLits</a> (const Lit &amp;, const Lit &amp;)</td></tr>
<tr class="memdesc:abe3f270ceed5598a0d7615c9ef355077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two Lits to the clause.  <a href="#abe3f270ceed5598a0d7615c9ef355077">More...</a><br /></td></tr>
<tr class="separator:abe3f270ceed5598a0d7615c9ef355077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272026139043c716b53613028ec88f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a272026139043c716b53613028ec88f4a">addLits</a> (const Lit &amp;, const Lit &amp;, const Lit &amp;)</td></tr>
<tr class="memdesc:a272026139043c716b53613028ec88f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds three Lits to the clause.  <a href="#a272026139043c716b53613028ec88f4a">More...</a><br /></td></tr>
<tr class="separator:a272026139043c716b53613028ec88f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df067c321eb85f5ea707095d48af6e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a5df067c321eb85f5ea707095d48af6e3">addLits</a> (const std::vector&lt; Lit &gt; &amp;)</td></tr>
<tr class="memdesc:a5df067c321eb85f5ea707095d48af6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vector of Lits to the clause.  <a href="#a5df067c321eb85f5ea707095d48af6e3">More...</a><br /></td></tr>
<tr class="separator:a5df067c321eb85f5ea707095d48af6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58314117668c47e619ec63204abe3c33"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Lit &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a58314117668c47e619ec63204abe3c33">getLits</a> () const</td></tr>
<tr class="memdesc:a58314117668c47e619ec63204abe3c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the literals in the clause.  <a href="#a58314117668c47e619ec63204abe3c33">More...</a><br /></td></tr>
<tr class="separator:a58314117668c47e619ec63204abe3c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cffa896ef6bcb10b562ffd46442632"><td class="memItemLeft" align="right" valign="top"><a id="a48cffa896ef6bcb10b562ffd46442632"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a48cffa896ef6bcb10b562ffd46442632">clear</a> ()</td></tr>
<tr class="memdesc:a48cffa896ef6bcb10b562ffd46442632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the clause by removing all the literals. <br /></td></tr>
<tr class="separator:a48cffa896ef6bcb10b562ffd46442632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c708a05f005fc6e4dd751f06a19b1a9"><td class="memItemLeft" align="right" valign="top"><a id="a7c708a05f005fc6e4dd751f06a19b1a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCClause.html#a7c708a05f005fc6e4dd751f06a19b1a9">printClause</a> ()</td></tr>
<tr class="memdesc:a7c708a05f005fc6e4dd751f06a19b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the clause. <br /></td></tr>
<tr class="separator:a7c708a05f005fc6e4dd751f06a19b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for representing a clause. </p>
<p>A clause is represented as a vector of Lits. This class defines operators for operations between clauses, such as AND, OR, NOT, and IMPLIES, and functions to add literals and work with them in the clause. After each operation, the clause is maintained in the CNF form. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae32c467fe55dc2302a4ea0d55daea9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32c467fe55dc2302a4ea0d55daea9b3">&#9670;&nbsp;</a></span>CClause() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CClause::CClause </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Lit &gt; &amp;&#160;</td>
          <td class="paramname"><em>lits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lits</td><td>The literals in the clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab80bc7f6d1c6a83d4992e4e7b8ad002a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80bc7f6d1c6a83d4992e4e7b8ad002a">&#9670;&nbsp;</a></span>CClause() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CClause::CClause </td>
          <td>(</td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lit</td><td>A literal, which creates a unit clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a801271e923e1c636c05b15d7ddbf58f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801271e923e1c636c05b15d7ddbf58f5">&#9670;&nbsp;</a></span>CClause() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CClause::CClause </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>A variable, which is converted to a Lit with positive polarity and added to create a unit clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a59375f274b0a5667a5fc6869b29e02e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59375f274b0a5667a5fc6869b29e02e3">&#9670;&nbsp;</a></span>addLits() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::addLits </td>
          <td>(</td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a Lit, a literal, to the clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lit1</td><td>The literal to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe3f270ceed5598a0d7615c9ef355077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3f270ceed5598a0d7615c9ef355077">&#9670;&nbsp;</a></span>addLits() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::addLits </td>
          <td>(</td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds two Lits to the clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lit1</td><td>The first Lit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lit2</td><td>The second Lit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a272026139043c716b53613028ec88f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272026139043c716b53613028ec88f4a">&#9670;&nbsp;</a></span>addLits() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::addLits </td>
          <td>(</td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lit &amp;&#160;</td>
          <td class="paramname"><em>lit3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds three Lits to the clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lit1</td><td>The first Lit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lit2</td><td>The second Lit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lit3</td><td>The third Lit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df067c321eb85f5ea707095d48af6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df067c321eb85f5ea707095d48af6e3">&#9670;&nbsp;</a></span>addLits() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::addLits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Lit &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherLits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vector of Lits to the clause. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherLits</td><td>The vector of Lits to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6053b23b6f497d0f95ebd97a5a962fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6053b23b6f497d0f95ebd97a5a962fc5">&#9670;&nbsp;</a></span>createLitAndAdd() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::createLitAndAdd </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Lit, a literal, given a variable, a Var, and adds it to the clause. </p>
<p>The literal is created with positive polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var1</td><td>The variable to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab00619c09bda108b810c6df25d3308ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00619c09bda108b810c6df25d3308ff">&#9670;&nbsp;</a></span>createLitAndAdd() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::createLitAndAdd </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates Lits given two Vars and adds them to the clause. </p>
<p>The literals are created with positive polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var1</td><td>The first Var </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var2</td><td>The second Var </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afde8b265a6235e778ba62e5b1287a541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde8b265a6235e778ba62e5b1287a541">&#9670;&nbsp;</a></span>createLitAndAdd() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CClause::createLitAndAdd </td>
          <td>(</td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Var &amp;&#160;</td>
          <td class="paramname"><em>var3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates Lits given three Vars and adds them to the clause. </p>
<p>The literals are created with positive polarity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var1</td><td>The first Var </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var2</td><td>The second Var </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var3</td><td>The third Var </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58314117668c47e619ec63204abe3c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58314117668c47e619ec63204abe3c33">&#9670;&nbsp;</a></span>getLits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Lit &gt; CClause::getLits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the literals in the clause. </p>
<dl class="section return"><dt>Returns</dt><dd>The literals in the clause </dd></dl>

</div>
</div>
<a id="a537843f7b72a69746dc3f9d63cc2d981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537843f7b72a69746dc3f9d63cc2d981">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classCClause.html">CClause</a> &gt; CClause::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCClause.html">CClause</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the operator to perform an implication with another clause. </p>
<p>Given this clause (a1 OR a2) and another clause (b1 OR b2), this defines ((a1 OR a2) -&gt; (b1 OR b2)). This is done using the fact that (p-&gt;q) is equivalent to (~p OR q). This clause acts as the antecedent, and the argument as the consequent. The result is converted to CNF form and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The clause which is the consequent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of clauses as a result of the implication </dd></dl>

</div>
</div>
<a id="aa225e0e4dc1c5025f5a2544a328e27df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa225e0e4dc1c5025f5a2544a328e27df">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClauses.html">Clauses</a> CClause::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClauses.html">Clauses</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the operator to perform an implication with a set of <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a>. </p>
<p>Given this clause p and a set of <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> q, this computes and returns (p-&gt;q) in CNF form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> which form the consequent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> object as a result of the implication </dd></dl>

</div>
</div>
<a id="acff25ccbdbc70021e59095715bd2334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff25ccbdbc70021e59095715bd2334c">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCClause.html">CClause</a> CClause::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCClause.html">CClause</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the operator to perform a disjunction of two clauses. </p>
<p>The disjunction of clause (a1 OR a2) and (b1 OR b2) is given by (a1 OR a2 OR b1 OR b2). This is achieved by appending the literals of the two clauses and returning the resultant clause. Extra checks are added to avoid repeating literals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The clause to disjunct with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The clause with the result on performing the OR operation </dd></dl>

</div>
</div>
<a id="acbfb51b369ecc9cf8a73b1b89bb9d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfb51b369ecc9cf8a73b1b89bb9d8c6">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClauses.html">Clauses</a> CClause::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClauses.html">Clauses</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the operator to perform a disjunction between a clause and a set of <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a>. </p>
<p>The working is described in the operator defined for OR between two <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> objects. This function converts the current clause to a <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> object and performs the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> to disjunct with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classClauses.html" title="Class for representing a set of clauses. ">Clauses</a> with the result of performing the AND operation </dd></dl>

</div>
</div>
<a id="a25ea1c0cecdb9cae3e705e54120ca1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ea1c0cecdb9cae3e705e54120ca1ea">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classCClause.html">CClause</a> &gt; CClause::operator~ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the operator to negate the clause in this object. </p>
<p>The negation of a clause (a1 OR a2 OR a3) is given by (~a1 AND ~a2 AND ~a3). Thus, the result is a set of clauses, and hence, this function returns this as a vector of <a class="el" href="classCClause.html" title="Class for representing a clause. ">CClause</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The negation of the clause </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="cclause_8h_source.html">cclause.h</a></li>
<li>src/cclause.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
